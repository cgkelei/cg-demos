float4x4 World : WorldMatrix;float4x4 ViewProj : ViewProjectionMatrix;float3 LightPos = float3(100, 100, 100);sampler2D DiffuseMap = sampler_state {	MinFilter = Linear;	MagFilter = Linear;	WrapS = Wrap;	WrapT = Wrap;} ;struct VS_INPUT{    float4 Position  : ATTR0;	float3 Normal    : ATTR1;	float2 Tex       : ATTR2;	float4 BlendWeights	: ATTR3;	int4 BlendIndices : ATTR4; };struct VS_OUTPUT{    float4 oPos       : POSITION;	float3 oNormal	  : TEXCOORD0;	float3 oLightDir  : TEXCOORD1;	float2 oTex		  : TEXCOORD2;};VS_OUTPUT vmain( VS_INPUT vInput ){    VS_OUTPUT vOutput;	float3 worldPos = (float3)( mul( vInput.Position, World) );	    vOutput.oPos = mul( vInput.Position,  mul(World, ViewProj) );		vOutput.oNormal = mul( vInput.Normal,  (float3x3)World);		vOutput.oTex = vInput.Tex;		vOutput.oLightDir = LightPos - worldPos;	    return vOutput;}float4 pmain( VS_OUTPUT pInput ) : COLOR{	float3 normal = pInput.oNormal;	normal = normalize(normal);		float3 light = pInput.oLightDir;	light = normalize(light);		float diffuseFactor = saturate( dot(normal, light) );	float3 diffuse = (float3)( tex2D(DiffuseMap, pInput.oTex)  );	return  float4( diffuse * diffuseFactor, 1);}technique LeftHandInOpenGL{    pass p0    {		CullFace = Back;         VertexProgram   = compile gp4vp vmain();        FragmentProgram = compile gp4fp pmain();    }}