<Effect name="DeferredLightingEffect">

<Shader name="DeferredLightingVS" stage="Vertex" entry="main">
	<ShaderSource>
	<![CDATA[
	
#version 330

// uniform
uniform mat4 WorldView;
uniform mat4 Projection;
uniform mat4 InvProj;

#if defined(DIRLIGHT)
in vec2 iPos;
out vec2 oTex;
#elif defined(POINTLIGHT) || defined(SPOTLIGHT)  
in vec3 iPos;
out vec3 oTex; // divide by w is wrong, w may negative, So pass the clip space coord to pixel shader
#endif

out vec3 oViewRay;

void main()
{
#if defined(DIRLIGHT)

	gl_Position = vec4(iPos, 0.0, 1.0);
	
	oTex = iPos * 0.5f + 0.5f;

	vec4 posVS = gl_Position * InvProj;
	oViewRay = vec3(posVS.xy / posVS.z, 1.0);       // Proj to Z=1 plane
	
#elif defined(POINTLIGHT) || defined(SPOTLIGHT)   
	
	vec4 viewPos = vec4(iPos, 1.0) * WorldView;
	oViewRay = viewPos.xyz;
	
	gl_Position = viewPos * Projection;
	oTex = vec3(gl_Position.xy, gl_Position.w);
#endif

}	
	]]>
	</ShaderSource>
</Shader>

<Shader name="DeferredDirectionalLightingPS" stage="Pixel" entry="main">
	<Include name="ShadowUtil.include.xml"/>
	<Include name="DeferredReadUtill.include.xml"/>
	<Include name="LightingUtil.include.xml"/>	
	<ShaderSource>
	<![CDATA[	
#version 330
#extension GL_EXT_texture_array : enable
	
uniform vec2 CameraNearFar;

uniform vec4 LightDirVS;	
uniform vec3 LightColor;

uniform mat4 InvView;			// Inv view matrix of current camera

uniform bool ShadowEnabled;
uniform bool VisiualizeCascades;

uniform sampler2D GBuffer0;	
uniform sampler2D DepthBuffer;	

in vec2 oTex;
in vec3 oViewRay;

out vec4 oFragColor;

const vec4 vCascadeColorsMultiplier[4] = vec4[4]
(
    vec4 ( 1.5, 0.0, 0.0, 1.0 ),
    vec4 ( 0.0, 1.5, 0.0, 1.0 ),
    vec4 ( 0.0, 0.0, 1.5, 1.0 ),
    vec4 ( 1.5, 1.5, 0.0, 1.0 )
);
	
void main()
{
	vec4 final = vec4(0.0);

	// Convert non-linear depth to view space linear depth
	float linearDepth = LinearizeDepth( texture2D(DepthBuffer, oTex).x, CameraNearFar.x, CameraNearFar.y );
	// View space lit position
	vec3 positionVS = PositionVSFromDepth(oViewRay, linearDepth);
	
	vec4 visibility = vec4(1.0);
	if (ShadowEnabled)
	{
		vec4 posWS = vec4(positionVS, 1.0) * InvView;
		
		int iCascadeSelected = 0;
		float percentLit = EvalCascadeShadow(posWS, iCascadeSelected);
		
		visibility = vec4(percentLit, percentLit, percentLit, percentLit);
		if (VisiualizeCascades)
			visibility *= vCascadeColorsMultiplier[iCascadeSelected];
	}
	
	// Fetch GBuffer
	vec4 tap0 = texture2D(GBuffer0, oTex);
				
	float shininess = tap0.a * 255.0;  			// specular power
	vec3 N = normalize(tap0.xyz * 2.0 - 1.0);   // view space normal
	vec3 L = normalize(-LightDirVS.xyz);		// light vector
		
	float nDotl = dot(L, N);
	if (nDotl > 0.0)
	{
		vec3 V = normalize(-positionVS);
		vec3 H = normalize(V + L);
		
		vec3 diffuse = LightColor * nDotl;
		
		// Frensel in moved to calculate in shading pass
		vec3 specular = CalculateSpecular(N, H, shininess) * LightColor * nDotl;
		
		final = vec4(diffuse, Luminance(specular));
	}
		
	oFragColor = final * visibility; 
}	
	]]>
	</ShaderSource>
</Shader>	

<Shader name="SpotLightingPS" stage="Pixel" entry="main">
	<Include name="DeferredReadUtill.include.xml"/>
	<Include name="LightingUtil.include.xml"/>
	<Include name="PossionPCF.include.xml"/>
<ShaderSource>
	<![CDATA[
	
#version 420
	
uniform vec4 LightPosVS;		// w dimension is spot light inner cone cos angle
uniform vec4 LightDirVS;		// w dimension is spot light outer cone cos angle
uniform vec3 LightColor;
uniform vec3 LightFalloff; 

uniform sampler2D GBuffer0;	
uniform sampler2D DepthBuffer;	

uniform vec2 CameraNearFar;
uniform mat4 InvView;			// Inv view matrix of current camera  
  
uniform bool ShadowEnabled; 
  
in vec3 oTex;
in vec3 oViewRay;

out vec4 oFragColor;

void main()
{
	vec4 final = vec4(0.0);

	vec2 tex = oTex.xy / oTex.z;
	tex = tex * 0.5 + 0.5;

	// Convert non-linear depth to view space linear depth
	float linearDepth = LinearizeDepth( texture2D(DepthBuffer, tex).x, CameraNearFar.x, CameraNearFar.y );
	// View space lit position
	vec3 positionVS = PositionVSFromDepth(oViewRay, linearDepth);
	
	float spot = SpotLighting(LightPosVS.xyz, LightDirVS.xyz, vec2(LightPosVS.w, LightDirVS.w), positionVS);
	if(spot > 0.0)
	{
		vec3 L = normalize(LightPosVS.xyz - positionVS);
		
		// Fetch GBuffer
		vec4 tap0 = texture2D(GBuffer0, tex);

		// Decode view space normal
		vec3 N = normalize(tap0.xyz * 2.0 - 1.0); 
		float shininess = tap0.a * 255.0;
	
		float nDotl = dot(L, N);
		if (nDotl > 0.0)
		{
			vec3 V = normalize(-positionVS);
			vec3 H = normalize(V + L);
		
			// calculate attenuation
			float attenuation = spot * CalcAttenuation(LightPosVS.xyz, positionVS, LightFalloff);	
			vec3 diffuse = LightColor * nDotl * attenuation;
		
			// Frensel in moved to calculate in shading pass
			vec3 specular = CalculateSpecular(N, H, shininess) * LightColor * nDotl * attenuation;
		
			final = vec4(diffuse, Luminance(specular));
		}
		
		float visibility = 1.0;
		if (ShadowEnabled)
			visibility = EvalCascadeShadow(vec4(positionVS, 1.0) * InvView);
	
		final *= visibility;
	}
		
	oFragColor = final; 
}		
	]]>
	</ShaderSource>
</Shader>	

<Shader name="PointLightingPS" stage="Pixel" entry="main">
	<Include name="DeferredReadUtill.include.xml"/>
	<Include name="LightingUtil.include.xml"/>
	<ShaderSource>
	<![CDATA[

#version 330
	
uniform vec2 CameraNearFar;

uniform vec4 LightPosVS;		// w dimension is spot light inner cone cos angle
uniform vec4 LightDirVS;		// w dimension is spot light outer cone cos angle
uniform vec3 LightColor;
uniform vec3 LightFalloff; 

uniform sampler2D GBuffer0;	
uniform sampler2D DepthBuffer;	
  
in vec3 oTex;
in vec3 oViewRay;

out vec4 oFragColor;

void main()
{
	vec4 final = vec4(0.0);

	vec2 tex = oTex.xy / oTex.z;
	tex = tex * 0.5 + 0.5;
	
	// Convert non-linear depth to view space linear depth
	float linearDepth = LinearizeDepth( texture2D(DepthBuffer, tex).x, CameraNearFar.x, CameraNearFar.y );
	// View space lit position
	vec3 positionVS = PositionVSFromDepth(oViewRay, linearDepth);
	
	vec3 L = normalize(LightPosVS.xyz - positionVS);
	
	// Fetch GBuffer
	vec4 tap0 = texture2D(GBuffer0, tex);

	// Decode view space normal
	vec3 N = normalize(tap0.xyz * 2.0 - 1.0); 
	float shininess = tap0.a * 255.0;
	
	float NdotL = dot(L, N);
	if (NdotL > 0.0)
	{
		vec3 V = normalize(-positionVS);
		vec3 H = normalize(V + L);
		
		// calculate attenuation
		float attenuation = CalcAttenuation(LightPosVS.xyz, positionVS, LightFalloff);
		
		vec3 diffuseLight = LightColor * NdotL * attenuation;	
		vec3 specularLight = CalculateSpecular(N, H, shininess) * diffuseLight; // Frensel in moved to calculate in shading pass
		
		final = vec4(diffuseLight, Luminance(specularLight));
	}
		
	oFragColor = final; 
}	
	]]>
	</ShaderSource>
</Shader>	

<Shader name="DeferredShadingPS" stage="Pixel" entry="main">
	<Include name="DeferredReadUtill.include.xml"/>
	<Include name="LightingUtil.include.xml"/>
	<ShaderSource>
	<![CDATA[
	
#version 330	
	
uniform sampler2D GBuffer0;           // Normal + Shininess
uniform sampler2D GBuffer1 ;
uniform sampler2D LightAccumulateBuffer;

in vec2 oTex;
in vec3 oViewRay;

out vec4 oFragColor;

// Deferred shading pass
void main()
{
	vec3 final = vec3(0, 0, 0);

	// Fetch GBuffer
	vec4 tap0 = texture2D( GBuffer0, oTex );
	vec4 tap1 = texture2D( GBuffer1, oTex );
	
	// Decode view space normal
	vec3 N = normalize(tap0.rgb * 2.0 - 1.0); 
	vec3 V = normalize(-oViewRay);

	// Get Diffuse Albedo and Specular
	vec3 diffuseAlbedo = tap1.rgb;
	vec3 specularAlbedo = tap1.aaa;
	float specularPower = tap0.a * 256.0;

	vec4 lightColor = texture(LightAccumulateBuffer, oTex);
	                    
	vec3 diffueLight = lightColor.rgb;
	vec3 specularLight = lightColor.a / (Luminance(diffueLight) + 1e-6) * diffueLight;

	// Approximate fresnel by N and V
	vec3 fresnelTerm = CalculateAmbiemtFresnel(specularAlbedo, N, V);
	
	final =  diffueLight * diffuseAlbedo + ((specularPower + 2.0) / 8.0) * fresnelTerm * specularLight;
	final = final + vec3(0.1, 0.1, 0.1) * diffuseAlbedo;

	oFragColor = vec4(final, 1.0);
}
	
		]]>
	</ShaderSource>
</Shader>	

<Shader name="FSQuadVS" stage="Vertex" entry="main">
	<ShaderSource>
	<![CDATA[
	
attribute vec2 iPos;
varying vec2 oTex;

void main()
{
	oTex = iPos * 0.5 + 0.5;
	gl_Position = vec4(iPos, 0.0, 1.0);	
	
}	
	]]>
	</ShaderSource>
</Shader>

<Shader name="CopyDepthPS" stage="Pixel" entry="main">
	<Include name="DeferredReadUtill.include.xml"/>
	<ShaderSource>
	<![CDATA[

uniform sampler2D DepthBuffer;	
varying vec2 oTex;

void main() 
{
	gl_FragDepth = texture2D( DepthBuffer, oTex ).r;
}
	]]>
	</ShaderSource>
</Shader>

<!-- Techniques -->
<Technique name="CopyDepth">
	<Pass name="p0">
		<VertexShader name="FSQuadVS"/>
		<PixelShader name="CopyDepthPS"/>
		<State name="DepthEnable" value="true"/>
		<State name="DepthFunc" value="Always"/>
		<State name="DepthWriteMask" value="true"/>
		<State name="ColorWriteMask" index="0" r="false" g="false" b="false" a="false"/> 
	</Pass>
</Technique>

<Technique name="DirectionalLighting">
	<Pass name="p0">
		<VertexShader name="DeferredLightingVS">
			<Macro name="DIRLIGHT"/>
		</VertexShader>
		<PixelShader name="DeferredDirectionalLightingPS">
			<Macro name="DIRLIGHT"/>
		</PixelShader>
		
		<!-- Only compute lighting in non-background region -->
		<State name="StencilEnable" value="true"/>
		<State name="FrontStencilFunc" value="NotEqual"/>
		<State name="FrontStencilFailOp" value="Keep"/>
		<State name="FrontStencilDepthFailOp" value="Keep"/>
		<State name="FrontStencilPassOp" value="Keep"/>
		<State name="FrontStencilRef" value="0"/>	
		
		<State name="DepthEnable" value="false"/>
		<State name="DepthWriteMask" value="false"/>
		<State name="BlendEnable" value="true"/>
		<State name="SrcBlend" value="One"/>
		<State name="DestBlend" value="One"/>
		<State name="BlendOp" value="Add"/>
		<State name="SrcBlendAlpha" value="One"/>
		<State name="DestBlendAlpha" value="One"/>
		<State name="BlendOpAlpha" value="Add"/>
  </Pass>
</Technique>

<Technique name="PointLighting">
	<Pass name="p0">
		<VertexShader name="DeferredLightingVS">
			<Macro name="POINTLIGHT"/>
		</VertexShader>
		<State name="ColorWriteMask" index="0" r="false" g="false" b="false" a="false"/> 
		<State name="DepthEnable" value="true"/>
		<State name="DepthWriteMask" value="false"/>
		<State name="DepthFunc" value="LessEqual"/>
		<State name="StencilEnable" value="true"/>
		<State name="FrontStencilFunc" value="Always"/>
		<State name="FrontStencilFailOp" value="Keep"/>
		<State name="FrontStencilDepthFailOp" value="DecrWrap"/>
		<State name="FrontStencilPassOp" value="Keep"/>
		<State name="BackStencilFunc" value="Always"/>
		<State name="BackStencilFailOp" value="Keep"/>
		<State name="BackStencilDepthFailOp" value="IncrWrap"/>	
		<State name="BackStencilPassOp" value="Keep"/>
		<State name="CullMode" value="None"/> 	
	</Pass>
	<Pass name="p1">
		<VertexShader name="DeferredLightingVS">
			<Macro name="POINTLIGHT"/>
		</VertexShader>
		<PixelShader name="PointLightingPS"/>
		<State name="DepthEnable" value="false"/>
		<State name="DepthWriteMask" value="false"/>
		<State name="DepthFunc" value="LessEqual"/>
		<State name="StencilEnable" value="true"/>
		<State name="BackStencilFunc" value="NotEqual"/>
		<State name="BackStencilFailOp" value="Keep"/>
		<State name="BackStencilDepthFailOp" value="Keep"/>	
		<State name="BackStencilPassOp" value="Zero"/>
		<State name="BackStencilRef" value="0"/>	
		<State name="CullMode" value="Front"/> 	
		<State name="BlendEnable" value="true"/>
		<State name="SrcBlend" value="One"/>
		<State name="DestBlend" value="One"/>
		<State name="BlendOp" value="Add"/>
		<State name="SrcBlendAlpha" value="One"/>
		<State name="DestBlendAlpha" value="One"/>
		<State name="BlendOpAlpha" value="Add"/> 
	</Pass>
</Technique>

<Technique name="SpotLighting">
	<Pass name="p0">
		<VertexShader name="DeferredLightingVS">
			<Macro name="SPOTLIGHT"/>
		</VertexShader>
		<State name="ColorWriteMask" index="0" r="false" g="false" b="false" a="false"/> 
		<State name="DepthEnable" value="true"/>
		<State name="DepthWriteMask" value="false"/>
		<State name="DepthFunc" value="LessEqual"/>
		<State name="StencilEnable" value="true"/>
		<State name="FrontStencilFunc" value="Always"/>
		<State name="FrontStencilFailOp" value="Keep"/>
		<State name="FrontStencilDepthFailOp" value="DecrWrap"/>
		<State name="FrontStencilPassOp" value="Keep"/>
		<State name="BackStencilFunc" value="Always"/>
		<State name="BackStencilFailOp" value="Keep"/>
		<State name="BackStencilDepthFailOp" value="IncrWrap"/>	
		<State name="BackStencilPassOp" value="Keep"/>
		<State name="CullMode" value="None"/> 	
	</Pass>
	<Pass name="p1">
		<VertexShader name="DeferredLightingVS">
			<Macro name="SPOTLIGHT"/>
		</VertexShader>
		<PixelShader name="SpotLightingPS"/>
		<State name="DepthEnable" value="false"/>
		<State name="DepthWriteMask" value="false"/>
		<State name="DepthFunc" value="LessEqual"/>
		<State name="StencilEnable" value="true"/>
		<State name="BackStencilFunc" value="NotEqual"/>
		<State name="BackStencilFailOp" value="Keep"/>
		<State name="BackStencilDepthFailOp" value="Keep"/>	
		<State name="BackStencilPassOp" value="Zero"/>
		<State name="BackStencilRef" value="0"/>	
		<State name="CullMode" value="Front"/> 	
		<State name="BlendEnable" value="true"/>
		<State name="SrcBlend" value="One"/>
		<State name="DestBlend" value="One"/>
		<State name="BlendOp" value="Add"/>
		<State name="SrcBlendAlpha" value="One"/>
		<State name="DestBlendAlpha" value="One"/>
		<State name="BlendOpAlpha" value="Add"/> 
	</Pass>
</Technique>

<Technique name="Shading">
	<Pass name="p0">
		<VertexShader name="DeferredLightingVS">
			<Macro name="DIRLIGHT"/>
		</VertexShader>
		<PixelShader name="DeferredShadingPS">
			<Macro name="DIRLIGHT"/>
		</PixelShader>
		<State name="DepthEnable" value="false"/>
		<State name="DepthWriteMask" value="false"/>	
	
		<!-- Only compute lighting in non-background region -->
		<State name="StencilEnable" value="true"/>
		<State name="FrontStencilFunc" value="NotEqual"/>
		<State name="FrontStencilFailOp" value="Keep"/>
		<State name="FrontStencilDepthFailOp" value="Keep"/>
		<State name="FrontStencilPassOp" value="Keep"/>
		<State name="FrontStencilRef" value="0"/>	
	</Pass>
</Technique>

</Effect>
	