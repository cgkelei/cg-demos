<Effect name="TangentFrame">

<Shader name="GeneralVS" stage="Vertex" entry="main">
	<ShaderSource>
	<![CDATA[
#version 330

// skin model will bake the world matrix into skin matrices
// we not support non-uniform scale, so the normal matrix is 
// simply the up 3x3 mat.
#ifdef _Skinning
	#define MaxNumBone 92
	uniform mat4 SkinMatrices[MaxNumBone];
#endif

// shader input
in vec3 iPos;

#ifdef _Skinning
	in vec4 iBlendWeights;
	in uvec4 iBlendIndices;
#endif

in vec3 iNormal;
in vec2 iTex;

#ifdef _NormalMap
	in vec3 iTangent;
	in vec3 iBinormal;
#endif

#ifdef _NormalMap
	out vec3 oNormal;
	out vec3 oTangent;
	out vec3 oBinormal;
#else
	out vec3 oNormal;
#endif

void main()
{
#ifdef _Skinning
	mat4 SkinMatrix = SkinMatrices[iBlendIndices[0]] * iBlendWeights[0] +
					  SkinMatrices[iBlendIndices[1]] * iBlendWeights[1] +
					  SkinMatrices[iBlendIndices[2]] * iBlendWeights[2] +
					  SkinMatrices[iBlendIndices[3]] * iBlendWeights[3];
#endif
	
	// calculate position in view space:
#ifdef _Skinning
	gl_Position = vec4(iPos, 1.0)* SkinMatrix;
#else
	gl_Position = vec4(iPos, 1.0);
#endif

	// calculate view space normal.
#ifdef _Skinning
	oNormal = normalize(iNormal * mat3(SkinMatrix));
#else
	oNormal = normalize(iNormal);
#endif

	// calculate tangent and binormal.
#ifdef _NormalMap
	#ifdef _Skinning
		oTangent = normalize(iTangent * mat3(SkinMatrix));
		oBinormal = normalize(iBinormal * mat3(SkinMatrix));
	#else
		oTangent = normalize(iTangent);
		oBinormal = normalize(iBinormal);
	#endif
#endif
}
	]]>
	</ShaderSource>
</Shader>

<Shader name="GeneralGS" stage="Geometry" entry="main">
	<ShaderSource>
	<![CDATA[
#version 330

layout(points) in; 
#ifdef _NormalMap
	layout(line_strip, max_vertices=6) out;
#else
	layout(line_strip, max_vertices=2) out;
#endif

uniform mat4 WorldViewProj;
const float normalScale = 0.5;

#ifdef _NormalMap
	in vec3 oNormal[];
	in vec3 oTangent[];
	in vec3 oBinormal[];
#else
	in vec3 oNormal[];
#endif 

out vec4 oColor;

void main()
{
	// we simply transform and emit the incoming vertex - this is v0 of our
    // line segment
    vec4 v0     = gl_in[0].gl_Position;
    gl_Position = v0 * WorldViewProj;
	oColor = vec4(0, 0, 1, 1);
    EmitVertex();

    // we calculate v1 of our line segment
    vec4 v1     = v0 + vec4(oNormal[0] * normalScale, 0);
    gl_Position = v1 * WorldViewProj;
	oColor = vec4(0, 0, 1, 1);
    EmitVertex();
	
	EndPrimitive();
	
#ifdef _NormalMap
	gl_Position = v0 * WorldViewProj;
	oColor = vec4(1, 0, 0, 1);
    EmitVertex();

    // we calculate v1 of our line segment
    vec4 v2     = v0 + vec4(oTangent[0] * normalScale, 0);
    gl_Position = v2 * WorldViewProj;
	oColor = vec4(1, 0, 0, 1);
    EmitVertex();
	
	EndPrimitive();
	
	gl_Position = v0 * WorldViewProj;
	oColor = vec4(0, 1, 0, 1);
    EmitVertex();

    // we calculate v1 of our line segment
    vec4 v3     = v0 + vec4(oBinormal[0] * normalScale, 0);
    gl_Position = v3 * WorldViewProj;
	oColor = vec4(0, 1, 0, 1);
    EmitVertex();

	EndPrimitive();
#endif
}
	]]>
	</ShaderSource>
</Shader>

<Shader name="GeneralPS" stage="Pixel" entry="main">
	<ShaderSource>
	<![CDATA[
#version 330

in vec4 oColor;
out vec4 oFragColor;

void main()
{
	oFragColor = oColor;
}
	]]>
	</ShaderSource>
</Shader>

<Technique name="ViewTangetFrame">
	<Pass name="p0">
		<VertexShader name="GeneralVS"/>
		<GeometryShader name="GeneralGS"/>
		<PixelShader name="GeneralPS"/>
	</Pass>
</Technique>

</Effect>