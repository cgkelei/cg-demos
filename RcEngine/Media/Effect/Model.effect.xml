<Effect name="ModelEffect">

<Shader name="ShadowMapVS" stage="Vertex" entry="main">
	<ShaderSource>
	<![CDATA[
	
#version 330	
	
// shader uniform 	
#ifdef _Skinning
	#define MaxNumBone 92
	uniform mat4 SkinMatrices[MaxNumBone];
#endif	
	
uniform mat4 WorldView;
uniform mat4 Proj;

// shader input
in vec3 iPos;

#ifdef _Skinning
	in vec4 iBlendWeights;
	in uvec4 iBlendIndices;
#endif

in vec3 iNormal;
in vec2 iTex;

#ifdef _NormalMap
	in vec3 iTangent;
	in vec3 iBinormal;
#endif

out float oDepth;

void main()
{
	#ifdef _Skinning
	mat4 SkinMatrix = SkinMatrices[iBlendIndices[0]] * iBlendWeights[0] +
					  SkinMatrices[iBlendIndices[1]] * iBlendWeights[1] +
					  SkinMatrices[iBlendIndices[2]] * iBlendWeights[2] +
					  SkinMatrices[iBlendIndices[3]] * iBlendWeights[3];
#endif
	
	// calculate position in world space:
#ifdef _Skinning
	gl_Position = vec4(iPos, 1.0)* SkinMatrix * WorldView * Proj;
#else
	gl_Position = vec4(iPos, 1.0) * WorldView * Proj;
#endif
	
	oDepth = gl_Position.z * 0.5 + 0.5;
}	
	]]>
	</ShaderSource>
</Shader>

<Shader name="ShadowMapPS" stage="Pixel" entry="main">
	<ShaderSource>
	<![CDATA[
	
#version 330	

in float oDepth;

// Variance Shadow Maps
#ifdef VSM
out vec2 oFragDepth;
#endif 

// Exponential Variance Shadow Maps
#ifdef EVSM
uniform vec2 EVSMConst;
out vec4 oFragDepth;
#endif 

// Exponential Shadow Maps
#ifdef ESM
uniform vec2 ESMConst;
out float oFragDepth;
#endif 

void main()
{
#ifdef VSM
	oFragDepth.x = oDepth;
	oFragDepth.y = oDepth * oDepth;
	
	//vec2 dxdy = vec2(dFdx(oDepth), dFdy(oDepth));
	//oFragDepth.y = oDepth * oDepth + 0.25 * dot(dxdy, dxdy);
#endif 

#ifdef EVSM
	float posDepth = exp(EVSMConst.x * oDepth);
	float negDepth = -exp(-EVSMConst.y * oDepth);

	oFragDepth = vec4(posDepth, posDepth * posDepth, negDepth, negDepth * negDepth);
#endif 

#ifdef ESM
	oFragDepth =  exp(ESMConst.x * oDepth);
#endif 
}
	]]>
	</ShaderSource>
</Shader>


<Shader name="GeneralVS" stage="Vertex" entry="main">
	<ShaderSource>
	<![CDATA[
#version 330

// skin model will bake the world matrix into skin matrices
// we not support non-uniform scale, so the normal matrix is 
// simply the up 3x3 mat.
#ifdef _Skinning
	#define MaxNumBone 92
	uniform mat4 SkinMatrices[MaxNumBone];
#endif

uniform mat4 WorldView;
uniform mat4 Proj;

// shader input
in vec3 iPos;

#ifdef _Skinning
	in vec4 iBlendWeights;
	in uvec4 iBlendIndices;
#endif

in vec3 iNormal;
in vec2 iTex;

#ifdef _NormalMap
	in vec3 iTangent;
	in vec3 iBinormal;
#endif

// shader out put
out vec4 oPosVS;
out vec2 oTex;

#ifdef _NormalMap
	out mat3 oTangentToView;
#else
	out vec3 oNormalVS;
#endif

void main()
{
#ifdef _Skinning
	mat4 SkinMatrix = SkinMatrices[iBlendIndices[0]] * iBlendWeights[0] +
					  SkinMatrices[iBlendIndices[1]] * iBlendWeights[1] +
					  SkinMatrices[iBlendIndices[2]] * iBlendWeights[2] +
					  SkinMatrices[iBlendIndices[3]] * iBlendWeights[3];
#endif
	
	// calculate position in view space:
#ifdef _Skinning
	mat4 SkinWorldView = SkinMatrix * WorldView;
	oPosVS = vec4(iPos, 1.0)* SkinWorldView;
#else
	oPosVS = vec4(iPos, 1.0) * WorldView;
#endif

	// calculate view space normal.
#ifdef _Skinning
	vec3 normal = normalize(iNormal * mat3(SkinWorldView));
#else
	vec3 normal = normalize(iNormal * mat3(WorldView));
#endif

	// calculate tangent and binormal.
#ifdef _NormalMap
	#ifdef _Skinning
		vec3 tangent = normalize(iTangent * mat3(SkinWorldView));
		vec3 binormal = normalize(iBinormal * mat3(SkinWorldView));
	#else
		vec3 tangent = normalize(iTangent * mat3(WorldView));
		vec3 binormal = normalize(iBinormal * mat3(WorldView));
	#endif

	// actualy this is a world to tangent matrix, because we always use V * Mat.
	oTangentToView = mat3( tangent, binormal, normal);

	// transpose to get tangent to world matrix
	oTangentToView = transpose(oTangentToView);
#else
	oNormalVS = normal;
#endif
	
	// texcoord
	oTex = vec2(iTex.x, 1.0 - iTex.y);
	gl_Position = oPosVS * Proj;
}
	]]>
	</ShaderSource>
</Shader>

<Shader name="GBufferPS" stage="Pixel" entry="main">
	<Include name="MaterialInput.include.xml"/>
	<ShaderSource>
	<![CDATA[
#version 330

uniform sampler2D BestNormalFitMap;

// shader input
in vec4 oPosVS;
in vec2 oTex;

#ifdef _NormalMap
	in mat3 oTangentToView;
#else
	in vec3 oNormalVS;
#endif

// shader output
out vec4 FragColor0; // Normal + shininess
out vec4 FragColor1; // Diffuse + Specular
	
// Best normal fit	
void CompressUnsignedNormalToNormalsBuffer(inout vec3 vNormal)
{
  // renormalize (needed if any blending or interpolation happened before)
  vNormal.rgb = normalize(vNormal.rgb);
  // get unsigned normal for cubemap lookup (note the full float precision is required)
  vec3 vNormalUns = abs(vNormal.rgb);
  // get the main axis for cubemap lookup
  float maxNAbs = max(vNormalUns.z, max(vNormalUns.x, vNormalUns.y));
  // get texture coordinates in a collapsed cubemap
  vec2 vTexCoord = vNormalUns.z<maxNAbs?(vNormalUns.y<maxNAbs?vNormalUns.yz:vNormalUns.xz):vNormalUns.xy;
  vTexCoord = vTexCoord.x < vTexCoord.y ? vTexCoord.yx : vTexCoord.xy;
  vTexCoord.y /= vTexCoord.x;
  
#ifndef Direct3D	
	vTexCoord.y = 1.0 - vTexCoord.y;
#endif
  
  // fit normal into the edge of unit cube
  vNormal.rgb /= maxNAbs;
  // look-up fitting length and scale the normal to get the best fit
  float fFittingScale = texture2D(BestNormalFitMap, vTexCoord).a;
  // scale the normal to get the best fit
  vNormal.rgb *= fFittingScale;
  // squeeze back to unsigned
  vNormal.rgb = vNormal.rgb * .5 + .5;
}

 float Luminance(in vec3 color)
 {
	return dot(color, vec3(0.2126, 0.7152, 0.0722));
 }

void main() 
{	
	// diffuse material
#ifdef _DiffuseMap
	vec4 diffuseTap = texture2D(DiffuseMap, oTex);
	vec3 albedo = diffuseTap.rgb;
	#ifdef _AlphaTest
		if( diffuseTap.a < 0.01 ) discard;
	#endif	
#else
	vec3 albedo = DiffuseColor;
#endif

	// specular material
#ifdef _SpecularMap
	vec4 specularTap = texture2D(SpecularMap, oTex);
	//vec3 specular = specularTap.rgb;
	vec3 specular = specularTap.rrr;
	#ifdef _GlossyMap
		float shininess = specularTap.a;
	#else 
		float shininess = Shininess / 255.0;
	#endif
#else
	vec3 specular = SpecularColor;
	float shininess = Shininess / 255.0;
#endif
	
	// normal map
#ifdef _NormalMap
	vec3 normal = texture2D( NormalMap, oTex ).rgb * 2.0 - 1.0;
	normal = normalize(normal * oTangentToView);
#else
	vec3 normal = normalize(oNormalVS);
#endif	
	
	//normal = normal * 0.5 + 0.5;
	CompressUnsignedNormalToNormalsBuffer(normal);	
	
	FragColor0 = vec4(normal.xyz, shininess);
	FragColor1 = vec4(albedo.rgb, Luminance(specular));	 // Specular luminance
}
	]]>
	</ShaderSource>
</Shader>


<!-- Forward lighting -->
<Shader name="DirectionalLightingPS" stage="Pixel" entry="main">
	<Include name="LightingUtil.include.xml"/>
	<Include name="MaterialInput.include.xml"/>
	<ShaderSource>
	<![CDATA[

#version 330	
	
uniform vec4 LightDirVS;
uniform vec3 LightColor;

// shader input
in vec4 oPosVS;
in vec2 oTex;

#ifdef _NormalMap
	in mat3 oTangentToView;
#else
	in vec3 oNormalVS;
#endif

out vec4 oFragColor;

void main()
{
	// diffuse material
#ifdef _DiffuseMap
	vec4 diffuseTap = texture2D(DiffuseMap, oTex);
	vec3 albedo = diffuseTap.rgb;
	#ifdef _AlphaTest
		if( diffuseTap.a < 0.01 ) discard;
	#endif	
#else
	vec3 albedo = DiffuseColor;
#endif

	// specular material
#ifdef _SpecularMap
	vec4 specularTap = texture2D(SpecularMap, oTex);
	//vec3 specular = specularTap.rgb;
	vec3 specular = specularTap.rrr;
	#ifdef _GlossyMap
		float shininess = specularTap.a * 255.0;
	#else 
		float shininess = Shininess;
	#endif
#else
	vec3 specular = SpecularColor;
	float shininess = Shininess;
#endif
	
	// normal map
#ifdef _NormalMap
	vec3 N = texture2D( NormalMap, oTex ).rgb * 2.0 - 1.0;
	N = normalize(N * oTangentToView);
#else
	vec3 N = normalize(oNormalVS);
#endif		
	
	vec3 L = normalize(-LightDirVS.xyz);
	vec3 V = normalize(-oPosVS.xyz);
	vec3 H = normalize(V + L);
		
		
	vec3 final = vec3(0);	
	float NdotL = dot(L, N);
	if (NdotL > 0.0)
	{
		float normTerm = (shininess + 2.0) / 8.0;
		float fresnel = CalculateFresnel(specular, L, H);
		final = (albedo + normTerm * CalculateSpecular(N, H, shininess) * fresnel) * LightColor * NdotL;
	}
	
	oFragColor = vec4(final, 1.0);
}
	]]>
	</ShaderSource>
</Shader>

<Technique name="VSM">
	<Pass name="p0">
		<VertexShader name="ShadowMapVS"/>
		<PixelShader name="ShadowMapPS">
			<Macro name="VSM"/>
		</PixelShader>
	</Pass>
</Technique>

<!-- pission disc PCF-->
<Technique name="PCF">
	<Pass name="p0">
		<VertexShader name="ShadowMapVS"/>
	</Pass>
</Technique>

<!--
<Technique name="EVSM">
	<Pass name="p0">
		<VertexShader name="ShadowMapVS"/>
		<PixelShader name="ShadowMapPS">
			<Macro name="EVSM"/>
		</PixelShader>
	</Pass>
</Technique>

<Technique name="ESM">
	<Pass name="p0">
		<VertexShader name="ShadowMapVS"/>
		<PixelShader name="ShadowMapPS">
			<Macro name="ESM"/>
		</PixelShader>
	</Pass>
</Technique>
-->

<Technique name="GBuffer">
	<Pass name="p0">
		<VertexShader name="GeneralVS"/>
		<PixelShader name="GBufferPS"/>
		<State name="StencilEnable" value="true"/>
		<State name="FrontStencilRef" value="1"/>
		<State name="FrontStencilFunc" value="Always"/>
		<State name="FrontStencilFailOp" value="Keep"/>
		<State name="FrontStencilDepthFailOp" value="Keep"/>
		<State name="FrontStencilPassOp" value="Replace"/>
	</Pass>
</Technique>

<Technique name="ForwardDirectionalLighting">
	<Pass name="p0">
		<VertexShader name="GeneralVS"/>
		<PixelShader name="DirectionalLightingPS"/>
  </Pass>
</Technique>

</Effect>
	
	